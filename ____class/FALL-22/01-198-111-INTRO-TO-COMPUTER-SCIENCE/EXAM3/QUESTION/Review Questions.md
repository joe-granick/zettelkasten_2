# Learning Objectives

## 3.1 OOP Using Abstract Data Types

#### (9.1a) Explain the meaning of data type.
https://www.youtube.com/watch?v=DY1ZqsYgWxs
- [ ] [[Q. data type 0]]
- [ ] [[Q. data type 1]]
- [ ] [[Q. data-type 2]]
- [ ] [[Q. data-type 3]]

#### (9.1b) Distinguish between object and reference.
https://www.youtube.com/watch?v=DY1ZqsYgWxs
- [ ] [[Q. objects 0]]
- [ ] [[Q. objects 1]]
- [ ] [[Q. objects 2]]
- [ ] [[Q. objects 6]]
- [ ] [[Q. objects 7]]
#### (9.1c) Distinguish between primitive data types and object references.
https://www.youtube.com/watch?v=DY1ZqsYgWxs
- [ ] [[Q. objects 3]]

#### (9.1d) Declare String reference variables and create String objects in a program.
https://youtu.be/sq-jPEP4qb8
- [ ] [[Q. strings 0]]
- [ ] [[Q. strings 1]]
- [ ] [[Q. strings 2]]
- [ ] [[Q. strings 3]]

#### (9.1e) Write code that manipulates/processes Strings by calling String methods.
https://youtu.be/sq-jPEP4qb8
- [ ] [[Q. objects 4]]
- [ ] [[Q. objects 5]]
- [ ] [[Q. strings 5]]
- [ ] [[Q. strings 6]]
- [ ] [[Q. strings 7]]
- [ ] [[Q. strings 8]]
- [ ] [[Q. strings 9]]
- [ ] [[Q. strings 10]]
- [ ] [[Q. strings 11]]
- [ ] [[Q. strings 12]]
- [ ] [[Q. strings 13]]
- [ ] [[Q. strings 14]]
- [ ] [[Q. strings 15]]
- [ ] [[Q. strings 16]]
- [ ] [[Q. strings 18]]
- [ ] [[Q. strings 19]]
- [ ] [[Q. strings 20]]
- [ ] [[Q. strings 21]]
- [ ] [[Q. strings 22]]
- [ ] [[Q. strings 23]]
- [ ] [[Q. strings 24]]
- [ ] [[Q. strings 25]]

#### (9.1f) Explain the immutability of Strings.
https://www.youtube.com/watch?v=0YdFgQ4ut6A
- [ ] [[Q. mutability 0]]
- [ ] [[Q. mutability 1]]
- [ ] [[Q. mutability 2]]
- [ ] [[Q. mutability 3]]
- [ ] [[Q. mutability 4]]
- [ ] [[Q. mutability 5]]
- [ ] [[Q. strings 4]]

#### (9.1g) Explain the results of concatenating Strings with primitive data types using the + operator.
- [ ] [[Q strings 17]]

#### (9.1h) Given a class API, write a client program that creates objects of that class and call methods defined for that class and illustrate the call stack and memory allocation for the execution of this client program.
https://www.youtube.com/watch?v=zaDZ0-Fd1mE
[[Q. execution and call stack]]

#### (9.1i) Use the concepts of Object Oriented Programming (classes, objects, and methods) to write a program that solves a problem.
https://youtu.be/_IsodO3xEfU
- [ ] [[Q. OOP 0]]
- [ ] [[Q. OOP 1]]
- [ ] [[OOP 2]]
- [ ] [[OOP 3]]
- [ ] [[Q. OOP 4]]
- [ ] [[Q. OOP 5]]
- [ ] [[Q. OOP 6]]
- [ ] [[Q. OOP 7]]
- [ ] [[Q. OOP 8]]
- [ ] [[Q. OOP 9]]
- [ ] [[Q. OOP 10]]
- [ ] [[Q. OOP 11]]

## 3.2 OOP Creating Data Types
#### (10.1a) Identify appropriate behaviors and attributes of real-world entities to create a class.

#### (10.1b) Write program code to define a new data type by creating a class.

#### (10.1c) Design and implement a simple class from given specifications.
- [ ] [[Q. creating data types 0]]
- [ ] [[Q. creating data types 1]]
- [ ] [[Q. creating data types 2]]
- [ ] [[Q. creating data types 3]]
- [ ] [[Q. creating data types 4]]
- [ ] [[Q. creating data types 5]]
- [ ] [[Q. creating data types 6]]
- [ ] [[Q. creating data types 7]]
- [ ] [[Q. creating data types 8]]
- [ ] [[Q. creating data types 9]]
- [ ] [[Q. creating data types 10]]
- [ ] [[Q. creating data types 11]]
- [ ] [[Q. creating data types 12]]


#### (10.1d) Explain the purpose of a constructor.
- [ ] [[Q. constructors 0]]

#### (10.1e) Explain the purpose of overloading constructors.

#### (10.1f) Distinguish among parameter variables, local variables, and instance variables.

#### (10.1g) Differentiate between public and private access modifiers.

#### (10.1h) Explain the purpose of declaring variables with the final modifier in a class.

#### (10.1i) Explain the difference between instance methods and class methods.

#### (10.1j) Write instance methods that have new data type objects as parameters.
- [ ] [[creating data types 2]]
#### (10.1k) Write instance methods that have new data type objects as return types.
- [ ] [[creating data types 3]]

#### (10.1l) Write instance methods that have new data type objects as local variables.

#### (10.1m) Write a client program that will create and use objects of a class that you wrote.

#### (10.1n) Write client programs that test all methods of your newly created data type.
[[Q. testing data-types 0]]

#### (10.1o) Document all instance methods by including pre- and post- conditions in your code.
- [ ] [[pre and post conditions 0]]
- [ ] [[pre and post conditions 1]]

## 4.1 Efficiency

### 11.1 Performance
#### (11.1a) Explain algorithmic efficiency as it relates to speed and space consumption.
- [ ] [[Q. memory and speed efficiency 0]]
- [ ] 

#### (11.1b) Recognize typical orders of complexity (O(1), O(log n), O(n), O(n log n), O(n^2), O(n^3), O(2^n))
- [ ] [[Q. big-o 6]]

#### (11.1c) Identify the basic operations in an algorithm and determine the running time of an algorithm by counting its basic operations.
- [ ] [[Q. memory and speed efficiency 1]]
- [ ] [[Q. memory and speed efficiency 2]]
- [ ] [[Q. basic operations 0]]

#### (11.1d) Express the running time of an algorithm as a function of the input size and derive the complexity class of the algorithm.

#### (11.1e) Categorize algorithms according to their Big O complexity.
- [ ] [[Q. big-o 0]]
- [ ] [[Q. big-o 1]]
- [ ] [[Q. big-o 2]]
- [ ] [[Q. big-o 3]]
- [ ] [[Q. big-o 4]]
- [ ] [[Q. big-o 5]]
- [ ] [[Q. big-o 7]]
- [ ] [[Q. big-o 8]]
- [ ] [[Q. big-o 9]]
- [ ] [[Q. big-o 10]]
- [ ] [[Q. big-o 11]]
- [ ] [[Q. big-o 12]]
- [ ] [[Q. big-o 13]]
- [ ] [[Q. big-o 14]]
- [ ] [[Q. big-o 15]]
- [ ] 
#### (11.1f) Describe space and time efficiency tradeoffs when designing algorithms.

#### (11.1g) Identify the best case, worst case, and average case Big O complexities of algorithms.

#### (11.1h) Compare the efficiencies of different algorithms that perform the same task.

### 11.2 ArrayList

#### (11.2a) 1. Represent collections of related object reference data using ArrayLists.

#### (11.2b) Implement Java code to manipulate ArrayLists including, but not limited to, the following tasks:
- Traverse and display the elements in an [[ArrayList]]
- Traverse using a for or while loop
- Traverse using an enhanced for loop
- Insert, delete, and modify objects in an ArrayList.

- [ ] [[Q. ArrayList 0]]
- [ ] [[Q. ArrayList 1]]
- [ ] [[Q. Arraylist 4]]

#### (11.2c) Explain the differences between the array and the ArrayList data structures.
#### (11.2.d) Compare the run time analysis for algorithms implementing arrays and algorithms implementing ArrayLists.
#### (11.2.e) Choose the appropriate data structure (arrays/ArrayLists) for use in a given application.
#### (11.2f) Compare the advantages and disadvantages of using Arrays and using ArrayLists in a Java program.

## 4.2 Searching and Sorting
- [ ] [[Q. search and sort algorithm selection 0]]
- [ ] [[Q. algorithmic problem solving 0]]
- [ ] [[Q. search and sort algorithm selection 1]]
- [ ] [[Q. memory and speed efficiency 8]]
- [ ] [[Q. algorithmic problem solving 1]]
### 12.1 Searching

#### (12.1a) Given an array /ArrayList of values, write a linear (sequential) search method to locate a specified value in the array. If the value is not present in the array, indicate that.
- [ ] [[Q. search 0]]
- [ ] [[Q. search 8]]

#### (12.1b) Given an ordered array/ArrayList of values, write a non-recursive binary search method to locate a specified value in the array/ArrayList. If the value is not present in the array/ArrayList, indicate that.
- [ ] [[Q. search 2]]
- [ ] [[Q. search 4]]
- [ ] [[Q. search 5]]
- [ ] [[Q. search 9]]
- [ ] [[Q. search 10]]

#### (12.1c) Count the number of comparisons made when a given search algorithm is executed and the search key and the array/ArrayList of values are provided.
- [ ] [[Q. search 1]]
- [ ] [[Q. search 3]]

#### (12.1d) Identify all elements in a given array/ArrayList that are examined when a given search algorithm is executed and the search key and the array of values are provided.
- [ ] [[Q. search 6]]
- [ ] [[Q. search 7]]


#### (12.1e) Determine the best case, and worst case Big-O analysis when a given search algorithm is executed and the search key and the array/ArrayList of values are provided.
- [ ] [[Q. memory and speed efficiency 3]]

### 12.2 Sorting

#### (12.2a) Given an array of values, give a step-by-step illustration of executing the selection sort on the array. State the array contents after each pass of the sort.
- [ ] [[Q. sort 0]]
- [ ] [[Q. sort 1]]
- [ ] [[Q. sort 2]]
- [ ] [[Q. sort 8]]

#### (12.2b) Given an array of values, give a step-by-step illustration of executing the insertion sort on the array. State the array contents after each pass of the sort.
- [ ] [[Q. sort 3]]
- [ ] [[Q. sort 4]]
- [ ] [[Q. sort 5]]
- [ ] [[Q. sort 7]]

#### (12.2c) Determine the best case and worst case Big-O analysis of the selection sort.

#### (12.2d) Determine the best case and worst case Big-O analysis of the insertion sort.
- [ ] [[Q. memory and speed efficiency 4]]
- [ ] [[Q. memory and speed efficiency 5]]

#### (12.2e) Write a program that sorts an array of numerical values using the selection/insertion sort
- [ ] [[Q. sort 6]]
- [ ] [[Q.. sort 7]]

#### (12.2f) Write a program that sorts an array/ArrayList of objects using the selection/insertion sort.

#### (12.2g) Compute statement execution counts and informal run-time comparison of sorting algorithms.
- [ ] [[Q. memory and speed efficiency 6]]



### (14.1) Recursive Binary Search

#### (14.1a) Given an ordered array of values, write a recursive binary search method to locate a specified value in the array. If the value is not present in the array, indicate that.
#### Identify the base case and the general case in the algorithm.
- [ ] [[Q. mergesort 0]]
- [ ] [[Q. mergesort 1]]
- [ ] [[Q. mergesort 2]]

#### (14.1b) Count the number of comparisons made when a recursive binary search algorithm is executed and the search key and the array of values are provided.

#### (14.1c) Identify all elements in a given array that are examined by a recursive binary search algorithm when the search key and the array of values are provided.

#### (14.1d) Determine the best case and worst case Big-O analysis for a recursive binary search algorithm when the search key and the array of values are provided.

#### (14.2) Mergesort and Analysis

#### (14.2a) Given an array of values, give a step-by-step illustration of executing the mergesort on the array. State the array contents after each pass of the sort.

#### (14.2b) Determine the best case and worst case Big-O analysis of the mergesort.
- [ ] [[Q. memory and speed efficiency 7]]

# Book
- [ ] Program 3.1.1 Identifying potential gene pg 337
	- [ ] `substring()` IS ALL **lower** CASE pg 332
- [ ] Program 3.1.2 AlbersSquares
	- [ ] how to draw nested rectangles
	- [ ] `StdDraw.filledSquare(x, y, r)` arguments
	- [ ] what does `import` do
- [ ] Program 3.1.3 `Grayscale` pg 348
- [ ] Program 3.1.4 `Scale` pg 350
	- [ ] New `Picture` needs to be initialized with `width` and `height`
	- [ ] `Picture(col, row)`
- [ ] Exercise **3.1.1** `reverse()`
	- [ ] properties of `substring`
	- [ ] attempt with character array
- [ ] 